"use strict";

const vm = require("vm");
const fs = require("fs");
const _ = require("lodash");
const Promise = require("bluebird");
const path = require("path");
const childCompiler = require("./lib/compiler.js");
const prettyError = require("./lib/errors.js");
const chunkSorter = require("./lib/chunksorter.js");
const backslashPattern = /\\/g;

Promise.promisifyAll(fs);

function HtmlWebpackPlugin (options) {
  this.options = _.extend({
    template: path.join(__dirname, "default_index.ejs"),
    filename: "index.html",
    hash: false,
    inject: true,
    compile: true,
    favicon: false,
    minify: false,
    cache: true,
    showErrors: true,
    chunks: "all",
    excludeChunks: [],
    title: "Webpack App",
    xhtml: false
  }, options);
}

HtmlWebpackPlugin.prototype.apply = function (compiler) {
    let self = this, isCompilationCached = false, compilationPromise, filename = this.options.filename;

    this.options.template = this.getFullTemplatePath(this.options.template, compiler.context);
    if (path.resolve(filename) === path.normalize(filename)) {
        this.options.filename = path.relative(compiler.options.output.path, filename);
    }

    compiler.plugin("make", function (compilation, callback) {
        compilationPromise =
            childCompiler.compileTemplate(self.options.template, compiler.context,
                                          self.options.filename, compilation)
                         .catch(function (err) {
                             compilation.errors.push(prettyError(err, compiler.context).toString());

                             return {
                                 content: self.options.showErrors ? prettyError(err, compiler.context).toJsonHtml() : "ERROR",
                                 outputName: self.options.filename
                             };
                         })
                         .then(function (compilationResult) {
                             isCompilationCached = compilationResult.hash && self.childCompilerHash === compilationResult.hash;
                             self.childCompilerHash = compilationResult.hash;
                             self.childCompilationOutputName = compilationResult.outputName;
                             callback();

                             return compilationResult.content;
                         });
    });

    compiler.plugin("emit", function (compilation, callback) {
        let applyPluginsAsyncWaterfall = self.applyPluginsAsyncWaterfall(compilation);
        let allChunks = compilation.getStats().toJson().chunks;
        let chunks = self.filterChunks(allChunks, self.options.chunks, self.options.excludeChunks);

        chunks = self.sortChunks(chunks, self.options.chunksSortMode);
        chunks = compilation.applyPluginsWaterfall("html-webpack-plugin-alter-chunks", chunks, { plugin: self });

        let assets = self.htmlWebpackPluginAssets(compilation, chunks);
        if (self.isHotUpdateCompilation(assets)) {
            return callback();
        }

        let assetJson = JSON.stringify(self.getAssetFiles(assets));
        if (isCompilationCached && self.options.cache && assetJson === self.assetJson) {
            return callback();
        }
        else {
            self.assetJson = assetJson;
        }

        Promise.resolve()
               .then(function () {
                   if (self.options.favicon) {
                       return self.addFileToAssets(self.options.favicon, compilation)
                         .then(function (faviconBasename) {
                             var publicPath = compilation.mainTemplate.getPublicPath({ hash: compilation.hash }) || "";
                             if (publicPath && publicPath.substr(-1) !== "/") {
                                 publicPath += "/";
                             }
                             assets.favicon = publicPath + faviconBasename;
                         });
                   }
               })
               .then(function () {
                   return compilationPromise;
               })
               .then(function (compiledTemplate) {
                   if (self.options.templateContent !== undefined) {
                       return self.options.templateContent;
                   }

                   return self.evaluateCompilationResult(compilation, compiledTemplate);
               })
               .then(function (compilationResult) {
                   return applyPluginsAsyncWaterfall("html-webpack-plugin-before-html-generation", false, {
                       assets: assets,
                       outputName: self.childCompilationOutputName,
                       plugin: self
                   }).then(function () {
                       return compilationResult;
                   });
               })
               .then(function (compilationResult) {
                   return typeof compilationResult !== "function" ?
                       compilationResult : self.executeTemplate(compilationResult, chunks, assets, compilation);
               })
               .then(function (html) {
                   let pluginArgs = { html: html, assets: assets, plugin: self, outputName: self.childCompilationOutputName };
                   return applyPluginsAsyncWaterfall("html-webpack-plugin-before-html-processing", true, pluginArgs);
               })
               .then(function (result) {
                   let html = result.html, assets = result.assets, assetTags = self.generateAssetTags(assets);
                   let pluginArgs = {
                       head: assetTags.head, body: assetTags.body, plugin: self,
                       chunks: chunks, outputName: self.childCompilationOutputName
                   };

                   return applyPluginsAsyncWaterfall("html-webpack-plugin-alter-asset-tags", true, pluginArgs)
                          .then(function (result) {
                              // Add the stylesheets, scripts and so on to the resulting html
                              return self.postProcessHtml(html, assets, { body: result.body, head: result.head })
                                .then(function (html) {
                                    return _.extend(result, { html: html, assets: assets });
                                });
                          });
               })
               .then(function (result) {
                   let html = result.html, assets = result.assets;
                   let pluginArgs = { html: html, assets: assets, plugin: self, outputName: self.childCompilationOutputName };

                   return applyPluginsAsyncWaterfall("html-webpack-plugin-after-html-processing", true, pluginArgs)
                          .then(function (result) {
                              return result.html;
                          });
               })
               .catch(function (err) {
                   compilation.errors.push(prettyError(err, compiler.context).toString());
                   self.hash = null;

                   return self.options.showErrors ? prettyError(err, compiler.context).toHtml() : "ERROR";
               })
               .then(function (html) {
                   compilation.assets[self.childCompilationOutputName] = {
                       source: function () {
                           return html;
                       },
                       size: function () {
                           return html.length;
                       }
                   };
               })
               .then(function () {
                   return applyPluginsAsyncWaterfall("html-webpack-plugin-after-emit", false, {
                       html: compilation.assets[self.childCompilationOutputName],
                       outputName: self.childCompilationOutputName,
                       plugin: self
                   }).catch(function (err) {
                       console.error(err);
                       return null;
                   }).then(function () {
                       return null;
                   });
               })
               .finally(function () {
                   callback();
                   return null;
               });
    })
}

HtmlWebpackPlugin.prototype.evaluateCompilationResult = function (compilation, source) {
    if (!source) {
        return Promise.reject("The child compilation didn't provide a result");
    }

    source = source.replace("var HTML_WEBPACK_PLUGIN_RESULT =", '');

    let template = this.options.template.replace(/^.+!/, '').replace(/\?.+$/, '');
    let vmContext = vm.createContext(_.extend({ HTML_WEBPACK_PLUGIN: true, require: require }, global));
    let vmScript = new vm.Script(source, { filename: template });
    let newSource;
 
    try {
        newSource = vmScript.runInContext(vmContext);
    }
    catch (e) {
        return Promise.reject(e);
    }

    if (typeof newSource === "object" && newSource.__esModule && newSource.default) {
        newSource = newSource.default;
    }

    return (typeof newSource === "string" || typeof newSource === "function") ?
                  Promise.resolve(newSource) : Promise.reject("The loader \"" + this.options.template + "\" didn't return html.");
}

HtmlWebpackPlugin.prototype.executeTemplate = function (templateFunction, chunks, assets, compilation) {
    let self = this;

    return Promise.resolve().then(function () {
        let templateParams = {
            compilation: compilation,
            webpack: compilation.getStats().toJson(),
            webpackConfig: compilation.options,
            htmlWebpackPlugin: {
                files: assets,
                options: self.options
            }
        }

        let html = '';
        try {
            html = templateFunction(templateParams);
        }
        catch (e) {
            compilation.errors.push(new Error("Template execution failed: " + e));
            return Promise.reject(e);
        }

        return html;
    });
}

HtmlWebpackPlugin.prototype.postProcessHtml = function (html, assets, assetTags) {
    let self = this;

    if (typeof html !== "string") {
        return Promise.reject("Expected html to be a string but got " + JSON.stringify(html));
    }

    return Promise.resolve()
                  .then(function () {
                      if (self.options.inject) {
                          return self.injectAssetsIntoHtml(html, assets, assetTags);
                      }
                      else {
                          return html;
                      }
                  })
                  .then(function (html) {
                      if (self.options.minify) {
                          let minify = require("html-minifier").minify;
                          return minify(html, self.options.minify);
                      }
                      return html;
                  });
}

HtmlWebpackPlugin.prototype.addFileToAssets = function (filename, compilation) {
    filename = path.resolve(compilation.compiler.context, filename);
    return Promise.props({
        size: fs.statAsync(filename),
        source: fs.readFileAsync(filename)
    })
    .catch(function () {
        return Promise.reject(new Error("HtmlWebpackPlugin: could not load file " + filename));
    })
    .then(function (results) {
        let basename = path.basename(filename);

        compilation.fileDependencies.push(filename);
        compilation.assets[basename] = {
            source: function () {
                return results.source;
            },
            size: function () {
                return results.size.size;
            }
        };

        return basename;
    });
}

HtmlWebpackPlugin.prototype.sortChunks = function (chunks, sortMode) {
    if (typeof sortMode === "undefined") {
        sortMode = "auto";
    }

    if (typeof sortMode === "function") {
        return chunks.sort(sortMode);
    }

    if (sortMode === "none") {
        return chunkSorter.none(chunks);
    }

    if (typeof chunkSorter[sortMode] !== "undefined") {
        return chunkSorter[sortMode](chunks, this.options.chunks);
    }

    throw new Error("\"" + sortMode + "\" is not a valid chunk sort mode");
}

HtmlWebpackPlugin.prototype.filterChunks = function (chunks, includedChunks, excludedChunks) {
    return chunks.filter(function (chunk) {
        let chunkName = chunk.names[0];

        if (chunkName === undefined) {
            return false;
        }

        if (typeof chunk.isInitial === "function") {
            if (!chunk.isInitial()) {
                return false;
            }
        }
        else if (!chunk.initial) {
            return false;
        }

        if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {
            return false;
        }

        if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {
            return false;
        }

        return true;
    });
}

HtmlWebpackPlugin.prototype.isHotUpdateCompilation = function (assets) {
    return assets.js.length && assets.js.every(function (name) {
        return /\.hot-update\.js$/.test(name);
    });
}

HtmlWebpackPlugin.prototype.htmlWebpackPluginAssets = function (compilation, chunks) {
    let self = this, js = [], css = [], compilationHash = compilation.hash,
        vendorRoot = this.options.vendorRoot, vendors = this.options.vendors;

    let publicPath = typeof compilation.options.output.publicPath !== "undefined"
                   ? compilation.mainTemplate.getPublicPath({ hash: compilationHash })
                   : path.relative(path.resolve(compilation.options.output.path, path.dirname(self.childCompilationOutputName)),
                                   compilation.options.output.path).replace(backslashPattern, '/');

    if (publicPath.length && publicPath.substr(-1, 1) !== '/') {
        publicPath += '/';
    }

    vendorRoot = path.relative(compilation.options.output.path, vendorRoot).replace(backslashPattern, '/');

    vendors.map(function (vendor) {
        if (/.css($|\?)/.test(vendor)) {
            css.push(vendorRoot + '/' + vendor);
        }
        else {
            js.push(vendorRoot + '/' + vendor);
        }
    });

    let assets = {
        publicPath: publicPath,
        chunks: {},
        js: js,
        css: css,
        manifest: Object.keys(compilation.assets).filter(function (assetFile) {
            return path.extname(assetFile) === ".appcache";
        })[0]
    }

    if (this.options.hash) {
        assets.manifest = self.appendHash(assets.manifest, compilationHash);
        assets.favicon = self.appendHash(assets.favicon, compilationHash);
    }

    for (var i = 0; i < chunks.length; i++) {
        let chunk = chunks[i], chunkName = chunk.names[0];

        assets.chunks[chunkName] = {};

        let chunkFiles = [].concat(chunk.files).map(function (chunkFile) {
            return publicPath + chunkFile;
        });

        if (this.options.hash) {
            chunkFiles = chunkFiles.map(function (chunkFile) {
                return self.appendHash(chunkFile, compilationHash);
            });
        }

        let entry = chunkFiles[0];

        assets.chunks[chunkName].size = chunk.size;
        assets.chunks[chunkName].entry = entry;
        assets.chunks[chunkName].hash = chunk.hash;
        assets.js.push(entry);

        let css = chunkFiles.filter(function (chunkFile) {
            return /.css($|\?)/.test(chunkFile);
        });
        assets.chunks[chunkName].css = css;
        assets.css = assets.css.concat(css);
    }
    assets.css = _.uniq(assets.css);

    return assets;
}

HtmlWebpackPlugin.prototype.generateAssetTags = function (assets) {

    let scripts = assets.js.map(function (scriptPath) {
        return {
            tagName: "script",
            closeTag: true,
            attributes: {
                type: "text/javascript",
                src: scriptPath
            }
        };
    });

    let selfClosingTag = !!this.options.xhtml;
    let styles = assets.css.map(function (stylePath) {
        return {
            tagName: "link",
            selfClosingTag: selfClosingTag,
            attributes: {
                href: stylePath,
                rel: "stylesheet"
            }
        };
    });

    let head = [], body = [];

    if (assets.favicon) {
        head.push({
            tagName: "link",
            selfClosingTag: selfClosingTag,
            attributes: {
                rel: "shortcut icon",
                href: assets.favicon
            }
        });
    }

    head = head.concat(styles);

    if (this.options.inject === "head") {
        head = head.concat(scripts);
    }
    else {
        body = body.concat(scripts);
    }

    return { head: head, body: body };
}

HtmlWebpackPlugin.prototype.injectAssetsIntoHtml = function (html, assets, assetTags) {
    let htmlRegExp = /(<html[^>]*>)/i, headRegExp = /(<\/head\s*>)/i, bodyRegExp = /(<\/body\s*>)/i;
    let body = assetTags.body.map(this.createHtmlTag), head = assetTags.head.map(this.createHtmlTag);

    if (body.length) {
        if (bodyRegExp.test(html)) {
            html = html.replace(bodyRegExp, function (match) {
                return body.join('') + match;
            });
        }
        else {
            html += body.join('');
        }
    }

    if (head.length) {
        if (!headRegExp.test(html)) {
            if (!htmlRegExp.test(html)) {
                html = "<head></head>" + html;
            }
            else {
                html = html.replace(htmlRegExp, function (match) {
                    return match + "<head></head>";
                });
            }
        }
        html = html.replace(headRegExp, function (match) {
            return head.join('') + match;
        });
    }

    if (assets.manifest) {
        html = html.replace(/(<html[^>]*)(>)/i, function (match, start, end) {
            if (/\smanifest\s*=/.test(match)) {
                return match;
            }
            return start + " manifest=\"" + assets.manifest + "\"" + end;
        });
    }

    return html;
}

HtmlWebpackPlugin.prototype.appendHash = function (url, hash) {
    if (!url) {
        return url;
    }
    return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;
}

HtmlWebpackPlugin.prototype.createHtmlTag = function (tagDefinition) {
    let attributes = Object.keys(tagDefinition.attributes || {})
                           .filter(function (attributeName) {
                               return tagDefinition.attributes[attributeName] !== false;
                           })
                           .map(function (attributeName) {
                               if (tagDefinition.attributes[attributeName] === true) {
                                   return attributeName;
                               }
                               return attributeName + "=\"" + tagDefinition.attributes[attributeName] + "\"";
                           });

    let voidTag = tagDefinition.voidTag !== undefined ? tagDefinition.voidTag : !tagDefinition.closeTag;
    let selfClosingTag = tagDefinition.voidTag !== undefined ? tagDefinition.voidTag && this.options.xhtml : tagDefinition.selfClosingTag;

    return '<' + [tagDefinition.tagName].concat(attributes).join(' ') + (selfClosingTag ? '/' : '') + '>' +
           (tagDefinition.innerHTML || '') + (voidTag ? '' : "</" + tagDefinition.tagName + '>');
}

HtmlWebpackPlugin.prototype.getFullTemplatePath = function (template, context) {
    if (template.indexOf('!') === -1) {
        template = require.resolve("./lib/loader.js") + '!' + path.resolve(context, template);
    }

    return template.replace(
      /([!])([^/\\][^!?]+|[^/\\!?])($|\?[^!?\n]+$)/,
      function (match, prefix, filepath, postfix) {
          return prefix + path.resolve(filepath) + postfix;
      });
}

HtmlWebpackPlugin.prototype.getAssetFiles = function (assets) {
    let files = _.uniq(Object.keys(assets).filter(function (assetType) {
        return assetType !== "chunks" && assets[assetType];
    }).reduce(function (files, assetType) {
        return files.concat(assets[assetType]);
    }, []));
    files.sort();

    return files;
}

HtmlWebpackPlugin.prototype.applyPluginsAsyncWaterfall = function (compilation) {
    let promisedApplyPluginsAsyncWaterfall = Promise.promisify(compilation.applyPluginsAsyncWaterfall, { context: compilation });

    return function (eventName, requiresResult, pluginArgs) {
        return promisedApplyPluginsAsyncWaterfall(eventName, pluginArgs)
               .then(function (result) {
                   if (requiresResult && !result) {
                       compilation.warnings.push(new Error("Using " + eventName + " without returning a result is deprecated."));
                   }
                   return _.extend(pluginArgs, result);
               });
    }
};

module.exports = HtmlWebpackPlugin;
