"use strict";

const Promise = require("bluebird");
const _ = require("lodash");
const path = require("path");
const webpackHome = "E:/NpmModules/node_modules/webpack";
const NodeTemplatePlugin = require(path.resolve(webpackHome, "lib/node/NodeTemplatePlugin"));
const NodeTargetPlugin = require(path.resolve(webpackHome, "lib/node/NodeTargetPlugin"));
const LoaderTargetPlugin = require(path.resolve(webpackHome, "lib/LoaderTargetPlugin"));
const LibraryTemplatePlugin = require(path.resolve(webpackHome, "lib/LibraryTemplatePlugin"));
const SingleEntryPlugin = require(path.resolve(webpackHome, "lib/SingleEntryPlugin"));

module.exports.compileTemplate = function compileTemplate(template, context, outputFilename, compilation) {
    let outputOptions = {
        filename: outputFilename,
        publicPath: compilation.outputOptions.publicPath
    };
    let assetsBeforeCompilation = _.assign({}, compilation.assets[outputOptions.filename]);
    let compilerName = getCompilerName(context, outputFilename);
    let childCompiler = compilation.createChildCompiler(compilerName, outputOptions);

    childCompiler.context = context;
    childCompiler.apply(
      new NodeTemplatePlugin(outputOptions),
      new NodeTargetPlugin(),
      new LibraryTemplatePlugin("HTML_WEBPACK_PLUGIN_RESULT", "var"),
      new SingleEntryPlugin(this.context, template),
      new LoaderTargetPlugin("node"));

    childCompiler.plugin("compilation", function (compilation) {
        if (compilation.cache) {
            if (!compilation.cache[compilerName]) {
                compilation.cache[compilerName] = {};
            }
            compilation.cache = compilation.cache[compilerName];
        }
    });

    return new Promise(function (resolve, reject) {
        childCompiler.runAsChild(function (err, entries, childCompilation) {
            if (childCompilation && childCompilation.errors && childCompilation.errors.length) {
                let errorDetails = childCompilation.errors.map(function (error) {
                    return error.message + (error.error ? ":\n" + error.error : '');
                }).join('\n');
                reject(new Error("Child compilation failed:\n" + errorDetails));
            }
            else if (err) {
                reject(err);
            }
            else {
                let outputName = compilation.mainTemplate.applyPluginsWaterfall("asset-path", outputOptions.filename, {
                    hash: childCompilation.hash,
                    chunk: entries[0]
                });

                compilation.assets[outputName] = assetsBeforeCompilation[outputName];
                if (assetsBeforeCompilation[outputName] === undefined) {
                    delete compilation.assets[outputName];
                }
                resolve({
                    hash: entries[0].hash,
                    outputName: outputName,
                    content: childCompilation.assets[outputName].source()
                });
            }
        });
    });
};

function getCompilerName(context, filename) {
    const absolutePath = path.resolve(context, filename);
    const relativePath = path.relative(context, absolutePath);

    return "html-webpack-plugin for \"" + (absolutePath.length < relativePath.length ? absolutePath : relativePath) + "\"";
}
